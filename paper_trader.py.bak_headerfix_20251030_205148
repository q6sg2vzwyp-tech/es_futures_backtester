#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ES Paper Trader (IBKR + ib_insync) â€” RT-only & OCO-hardened build (with fixes baked in)

Core:
- Paper-only safety by default
- Thompson Sampling learner (shadow/advisory/control)
- Risk profiles: balanced/aggressive/conservative
- OCO protection builder & audit (orphan sweeps, sibling cancel, refresh if missing)
- VWAP session + optional short guards (VWAP buffer + lower-high)
- Session cutovers (multi) + persistent day guard
- Version-safe IB PnL subscription + NetLiq via accountValueEvent
- 24/5 trading window by default (no TOD blackouts unless provided)
- 1-second JSON heartbeats with explicit idle reasons & RT status/age/queue
- Robust RTâ†’Polling fallback (5s bars via historical polling)

NEW (this build):
- RT-ONLY mode: --rt-only (no polling, no trading until RT is FRESH; ignores --force-delayed)
- Safer stop/OCO: triggerMethod=2; rescue refresh is rate-limited; wrong-side child purge
- Trade count increments when parent order actually becomes working (not merely submitted)
- Margin rejection (201 insufficient) â†’ 60s backoff
- Commission tracking via commissionReportEvent (clarified signature)
- VWAP only ingests TRADES bars (RT + polled), never MIDPOINT
- Day-state persistence (realized & peak), weekly R reset, cap guards

Fixes in this release:
- Hard lock to prevent polling in --rt-only mode (including force_no_bar_poll edge).
- Cleaner account update subscription (benign error handling).
- Heartbeat logs: rt_age_sec coerced to int.
- Skip orphan sweeps during active position when RT is starved/stale to avoid racing fills.
- OCO rescue: micro re-check to prevent flicker; rate-limited.
- Ensure parent orderId is assigned before submitting children; fail gracefully otherwise.
- Post-flat cleanup also cancels lingering parent LMTs.
- First-run: ensure .\\logs and .\\data\\state directories exist.
- Optional audible cue on caps_on (Windows only).
"""

from __future__ import annotations

import sys, os, time, json, math, random, argparse, datetime as dt, traceback, threading, platform
from typing import Optional, List, Dict, Any, Tuple
from types import SimpleNamespace
try:
    import winsound  # Windows beep (optional)
except Exception:
    winsound = None

from ib_insync import IB, Future, Contract, LimitOrder, StopOrder, MarketOrder, Trade

# ---------- Utilities ----------
def utc_now_str() -> str:
    return dt.datetime.now(dt.timezone.utc).strftime("%Y-%m-%d %H:%M:%S")

def ct_now() -> dt.datetime:
    return dt.datetime.now()

def parse_hhmm(s: str) -> dt.time:
    h, m = s.split(":")
    return dt.time(int(h), int(m))

def clamp(x, lo, hi): return max(lo, min(hi, x))
def ticks_to_price_delta(ticks: int, tick_size: float) -> float: return float(ticks) * float(tick_size)
def round_to_tick(p: float, tick: float) -> float: return round(p / tick) * tick if tick > 0 else p
def to_iso_utc_local_naive(d: dt.datetime) -> str:
    try:
        return dt.datetime.fromtimestamp(d.timestamp(), tz=dt.timezone.utc).strftime('%Y-%m-%dT%H:%M:%SZ')
    except Exception:
        try:
            return d.isoformat()
        except Exception:
            return str(d)

def log(evt: str, **fields):
    payload = {"ts": utc_now_str(), "evt": evt}
    payload.update(fields)
    print(json.dumps(payload, ensure_ascii=False), flush=True)

# ---------- Math / indicators ----------
def ema(vals: List[float], span: int) -> float:
    if not vals: return float("nan")
    k = 2 / (span + 1)
    s = vals[0]
    for v in vals[1:]:
        s = v * k + s * (1 - k)
    return s

def atr(H: List[float], L: List[float], C: List[float], n: int = 14) -> float:
    if len(C) < n + 1: return float("nan")
    trs = []
    for i in range(1, len(C)):
        hl = H[i] - L[i]
        hc = abs(H[i] - C[i - 1])
        lc = abs(L[i] - C[i - 1])
        trs.append(max(hl, hc, lc))
    if len(trs) < n: return float("nan")
    k = 2 / (n + 1)
    s = trs[-n]
    for v in trs[-n + 1:]:
        s = v * k + s * (1 - k)
    return s

# ---------- Session helpers ----------
def parse_ct_list(spec: str) -> List[dt.time]:
    spec = (spec or "").strip()
    if not spec:
        return [parse_hhmm("16:10")]
    out = []
    for chunk in spec.split(","):
        chunk = chunk.strip()
        if not chunk:
            continue
            out.append(parse_hhmm(chunk))
        except Exception:
            pass
    out = sorted(list({t for t in out}))
    return out or [parse_hhmm("16:10")]

def within_session(now: dt.datetime, start_ct: str, end_ct: str) -> bool:
    t = now.time()
    a = parse_hhmm(start_ct)
    b = parse_hhmm(end_ct)
    if a <= b:
        return a <= t <= b
    return (t >= a) or (t <= b)

def parse_blackouts(spec: str) -> List[Tuple[dt.time, dt.time]]:
    out = []
    spec = (spec or "").strip()
    if not spec: return out
    for chunk in spec.split(","):
        chunk = chunk.strip()
        if not chunk: continue
            a, b = chunk.split("-")
            out.append((parse_hhmm(a), parse_hhmm(b)))
        except Exception:
            pass
    return out

def in_tod_blackout(now: dt.datetime, blackouts: List[Tuple[dt.time, dt.time]]) -> bool:
    if not blackouts: return False
    t = now.time()
    for a, b in blackouts:
        if a <= b:
            if a <= t <= b: return True
        else:  # crosses midnight
            if (t >= a) or (t <= b): return True
    return False

def session_key_multi(now: dt.datetime, reset_times: List[dt.time]) -> str:
    t = now.time()
    idx_today = -1
    for i, ct_ in enumerate(reset_times):
        if t >= ct_:
            idx_today = i
        else:
            break
    if idx_today >= 0:
        base_date = now.date()
        seg = idx_today
    else:
        base_date = (now - dt.timedelta(days=1)).date()
        seg = len(reset_times) - 1
    return f"{base_date.strftime('%Y-%m-%d')}-S{seg}"

def reset_due_multi(now: dt.datetime, reset_times: List[dt.time], last_reset_marks: Dict[str, str]) -> Optional[str]:
    today = now.date().strftime("%Y-%m-%d")
    for ct_ in reset_times:
        label = ct_.strftime("%H:%M")
        if last_reset_marks.get(label) == today:
            continue
        if now.time() >= ct_:
            last_reset_marks[label] = today
            return f"{today}#{label}"
    return None

# ---------- Heartbeat (thread) ----------
_hb_lock = threading.Lock()
_hb_state: Dict[str, Any] = {
    "state": "-",
    "idle_reason": "starting_or_quiet",
    "net_qty": 0,
    "bars": 0,
    "rt_enabled": False,
    "rt_status": "disabled",
    "rt_age_sec": None,
    "rt_queue_len": 0,
    "in_session_window": False,
    "caps": [],
    "news_kill": False,
    "dayR": 0.0,
    "trades_today": 0,
    "cool_until": None,
    "orders_disabled_paper_safety": False,
}

def hb_update(**kv):
        if "cool_until" in kv and isinstance(kv["cool_until"], dt.datetime):
            kv["cool_until"] = to_iso_utc_local_naive(kv["cool_until"])
    except Exception:
        pass
    with _hb_lock:
        _hb_state.update(kv)

def _hb_loop():
    while True:
        with _hb_lock:
            payload = dict(_hb_state)
        log("hb", **payload)
        time.sleep(1.0)

def start_heartbeat_thread():
    t = threading.Thread(target=_hb_loop, daemon=True)
    t.start()

# ---------- IB helpers ----------
ACTIVE_STATUSES = {"Submitted", "PreSubmitted", "ApiPending", "PendingSubmit", "PendingCancel", "Inactive"}
CANCELLABLE_STATUSES = {"Submitted", "PreSubmitted", "ApiPending", "PendingSubmit"}

def _parse_ib_date(s: str) -> Optional[dt.date]:
        return dt.datetime.strptime(s, "%Y%m%d").date()
    except Exception:
            return dt.datetime.strptime(s, "%Y%m%d%H:%M:%S").date()
        except Exception:
            return None

def qualify_local_symbol(ib: IB, local_symbol: str, exchange="CME"):
    cds = ib.reqContractDetails(Future(localSymbol=local_symbol, exchange=exchange))
    if not cds:
        raise RuntimeError(f"Local symbol {local_symbol} not found on {exchange}")
    con = cds[0].contract
    ib.qualifyContracts(con)
    return con

def mk_contract(ib: IB, args) -> Contract:
    if getattr(args, "local_symbol", None):
        con = qualify_local_symbol(ib, args.local_symbol, "CME")
        print(f"[CONTRACT] Using {con.localSymbol} conId={con.conId} exp={con.lastTradeDateOrContractMonth}")
        return con
    cds = ib.reqContractDetails(Future(symbol=args.symbol, exchange="CME", currency="USD"))
    if not cds:
        raise RuntimeError(f"Symbol {args.symbol} not found on CME; supply --local-symbol")
    best, best_date = None, None
    for cd in cds:
        d = _parse_ib_date(cd.contract.lastTradeDateOrContractMonth)
        if not d:
            continue
        if best is None or d < best_date:
            best, best_date = cd.contract, d
    if best is None:
        raise RuntimeError("Could not resolve front contract; supply --local-symbol")
    ib.qualifyContracts(best)
    print(f"[CONTRACT] Using {best.localSymbol} conId={best.conId} exp={best.lastTradeDateOrContractMonth}")
    return best

def contract_multiplier(ib: IB, con: Contract) -> float:
        cds = ib.reqContractDetails(con)
        mul = cds[0].contract.multiplier
        m = float(mul) if mul is not None else 1.0
        return m if m > 0 else 1.0
    except Exception:
        return 1.0

def ib_position_truth(ib: IB, con: Contract) -> Tuple[int, Optional[float]]:
        qty = 0
        avg = None
        for p in ib.positions():
            if getattr(p.contract, "conId", None) == con.conId:
                qty += int(round(p.position))
                avg = float(p.avgCost)
        return qty, avg
    except Exception:
        return 0, None

def has_active_parent_entry(ib: IB, con: Contract) -> bool:
        ib.reqOpenOrders()
        ib.sleep(0.20)
        for t in ib.openTrades():
            if getattr(t.contract, "conId", None) != con.conId:
                continue
                if hasattr(t, "isActive") and callable(t.isActive) and not t.isActive():
                    continue
            except Exception:
                pass
            st = (getattr(t.orderStatus, "status", "") or "").strip()
            if st not in ACTIVE_STATUSES: continue
            ot = (getattr(t.order, "orderType", "") or "").upper()
            if ot != "LMT": continue
            if getattr(t.order, "parentId", 0) not in (None, 0): continue
            act = (getattr(t.order, "action", "") or "").upper()
            if act not in ("BUY", "SELL"): continue
            rem = getattr(t.orderStatus, "remaining", None)
            if rem is not None and float(rem) <= 0: continue
            return True
    except Exception:
        pass
    return False

def list_open_orders_for_contract(ib: IB, con: Contract) -> List[Trade]:
    trades = []
        for t in ib.openTrades():
            if getattr(t.contract, "conId", None) == con.conId:
                st = (t.orderStatus.status or "").strip()
                if st in ACTIVE_STATUSES:
                    trades.append(t)
    except Exception:
        pass
    return trades

def safe_cancel(ib: IB, order_or_trade, note: str = ""):
        if hasattr(order_or_trade, 'orderStatus'):
            st = (order_or_trade.orderStatus.status or "").strip()
            oid = order_or_trade.order.orderId
            tgt = order_or_trade.order
        else:
            st = (getattr(order_or_trade, 'status', None) or "").strip()
            oid = getattr(order_or_trade, 'orderId', None)
            tgt = order_or_trade
        if st and st not in CANCELLABLE_STATUSES:
            return
        ib.cancelOrder(tgt)
        log("cancel_sent", orderId=oid, note=note)
    except Exception as e:
        msg = str(e)
        if "Error 161" in msg:
            log("cancel_ignored_161", orderId=oid, note=note)
        else:
            log("cancel_warn", orderId=oid, err=msg, note=note)

def cancel_siblings_for_trade(ib: IB, trade: Trade, con: Contract):
    """
    Cancel *only* opposite-side **PARENT** entries for this contract.
    Never cancel OCO children (stop/TP). Children have parentId!=0 or ocaGroup set.
    """
        my_side = (trade.order.action or "").upper()   # "BUY"/"SELL"
        opp = "SELL" if my_side == "BUY" else "BUY"

        parentId = getattr(trade.order, "parentId", 0) or 0
        if parentId not in (None, 0) or bool((trade.order.ocaGroup or "").strip()):
            return

        for t in ib.openTrades():
            if getattr(t.contract, "conId", None) != con.conId:
                continue
            st = (t.orderStatus.status or "").strip()
            if st not in ACTIVE_STATUSES:
                continue
            if (getattr(t.order, "parentId", 0) not in (None, 0)) or bool((t.order.ocaGroup or "").strip()):
                continue
            ot = (t.order.orderType or "").upper()
            act = (t.order.action or "").upper()
            if ot == "LMT" and act == opp:
                safe_cancel(ib, t, note="[sibling parent-entry only]")
    except Exception as e:
        log("sibling_cancel_err", err=str(e))

def reconcile_orphans(ib: IB, account: str, con: Contract):
    """
    Aggressively cancel true orphans for *this* contract:
      - Only when FLAT
      - Only when there is NO active parent LIMIT entry working
      - Cancels any child/OCA exits, including Inactive/PendingCancel/ApiPending
    """
        qty, _ = ib_position_truth(ib, con)
        if qty != 0 or has_active_parent_entry(ib, con):
            return
            ib.reqOpenOrders()
            ib.sleep(0.15)
        except Exception:
            pass
        cancelled = 0
        for t in list(ib.openTrades()):
            if getattr(t.contract, "conId", None) != con.conId:
                continue
            st = (getattr(t.orderStatus, "status", "") or "").strip()
            is_child = (getattr(t.order, "parentId", 0) not in (None, 0)) or bool((t.order.ocaGroup or "").strip())
            if is_child and st in {"ApiPending", "PendingSubmit", "PendingCancel", "PreSubmitted", "Submitted", "Inactive"}:
                safe_cancel(ib, t, note="[ORPHAN SWEEP v2]"); cancelled += 1
        for t in list(ib.trades()):
            if getattr(t.contract, "conId", None) != con.conId:
                continue
            st = (getattr(t.orderStatus, "status", "") or "").strip()
            if st in ("Filled", "Cancelled"): continue
            is_child = (getattr(t.order, "parentId", 0) not in (None, 0)) or bool((t.order.ocaGroup or "").strip())
            if is_child:
                safe_cancel(ib, t, note="[ORPHAN SWEEP v2: allTrades]"); cancelled += 1
        if cancelled:
            log("orphan_sweep_done", count=cancelled)
    except Exception as e:
        log("orphan_sweep_err", err=str(e))

def post_flat_cleanup(ib: IB, con: Contract, note: str = "[post_flat_sweep]"):
    """Cancel any non-filled orders for this contract right after we're FLAT, including lingering parents."""
            ib.reqOpenOrders()
            ib.sleep(0.15)
        except Exception:
            pass

        qty, _ = ib_position_truth(ib, con)
        if qty != 0:
            return

        cancelled = 0
        # Children
        for t in list(ib.openTrades()):
            if getattr(t.contract, "conId", None) != con.conId: continue
            st = (getattr(t.orderStatus, "status", "") or "").strip()
            if st not in ("Filled", "Cancelled"):
                safe_cancel(ib, t, note=note); cancelled += 1

        for t in list(ib.trades()):
            if getattr(t.contract, "conId", None) != con.conId: continue
            st = (getattr(t.orderStatus, "status", "") or "").strip()
            if st not in ("Filled", "Cancelled"):
                safe_cancel(ib, t, note=note); cancelled += 1

        # Parents (extra safety)
        for t in list(ib.openTrades()):
            if getattr(t.contract, "conId", None) != con.conId: continue
            st = (getattr(t.orderStatus, "status", "") or "").strip()
            if st not in ("Filled", "Cancelled"):
                is_parent = (getattr(t.order, "parentId", 0) in (None, 0)) and not bool((t.order.ocaGroup or "").strip())
                if is_parent:
                    safe_cancel(ib, t, note=note); cancelled += 1

        if cancelled:
            log("post_flat_sweep_done", count=cancelled)
    except Exception as e:
        log("post_flat_sweep_err", err=str(e))

def sweep_all_for_contract(ib: IB, con: Contract, note: str = "[PANIC SWEEP]"):
    """Contract-scoped 'global cancel' when flat: cancels *any* non-filled order (parent or child)."""
        qty, _ = ib_position_truth(ib, con)
        if qty != 0:
            return
            ib.reqOpenOrders(); ib.sleep(0.15)
        except Exception:
            pass
        cancelled = 0
        for t in list(ib.openTrades()):
            if getattr(t.contract, "conId", None) != con.conId: continue
            st = (getattr(t.orderStatus, "status", "") or "").strip()
            if st not in ("Filled", "Cancelled"):
                safe_cancel(ib, t, note=note); cancelled += 1
        for t in list(ib.trades()):
            if getattr(t.contract, "conId", None) != con.conId: continue
            st = (getattr(t.orderStatus, "status", "") or "").strip()
            if st not in ("Filled", "Cancelled"):
                safe_cancel(ib, t, note=note); cancelled += 1
        if cancelled:
            log("sweep_done", count=cancelled)
    except Exception as e:
        log("sweep_err", err=str(e))

# ---------- Risk & sizing ----------
class DayRisk:
    def __init__(self, loss_cap_R: float, max_trades: int, max_consec_losses: int):
        self.loss_cap_R = float(loss_cap_R)
        self.max_trades = int(max_trades)
        self.max_consec_losses = int(max_consec_losses)
        self.reset()

    def reset(self):
        self.day_R = 0.0
        self.trades = 0
        self.cool_until: Optional[dt.datetime] = None
        self.halted = False
        self.last_entry_time: Optional[float] = None
        self.consec_losses = 0

    def can_trade(self, now: dt.datetime, min_gap_s: int) -> bool:
        if self.halted:
            return False
        if self.cool_until and now < self.cool_until:
            return False
        if self.trades >= self.max_trades:
            return False
        if self.day_R <= -abs(self.loss_cap_R):
            return False
        if self.consec_losses >= self.max_consec_losses:
            return False
        if self.last_entry_time and (time.time() - self.last_entry_time) < max(0, min_gap_s):
            return False
        return True

def iso_week_id(d: dt.date) -> str:
    y, w, _ = d.isocalendar()
    return f"{y}-W{int(w):02d}"

def decay_factor_from_half_life(hl_trades: float) -> float:
    hl = max(1.0, float(hl_trades))
    return math.exp(math.log(0.5)/hl)

# ---------- VWAP ----------
class SessionVWAP:
    def __init__(self):
        self.pv = 0.0
        self.v = 0.0
        self.vwap = float("nan")
    def reset(self):
        self.pv = 0.0
        self.v = 0.0
        self.vwap = float("nan")
    def update_bar(self, close_px: Optional[float], volume: Optional[float]):
            if close_px is None or volume is None: return
            vol = max(0.0, float(volume))
            if vol <= 0: return
            px = float(close_px)
            self.pv += px * vol
            self.v += vol
            if self.v > 0: self.vwap = self.pv / self.v
        except Exception:
            pass

# ---------- CLI ----------
def build_argparser():
    epilog = """
Examples:
  paper_trader.py --local-symbol ESZ5 --place-orders --use-ib-pnl --learn-mode advisory
  paper_trader.py --local-symbol ESZ5 --place-orders --rt-only --require-rt-before-trading
    """.strip()

    ap = argparse.ArgumentParser(
        description="ES Paper Trader (session-aware + Thompson learner + rails)",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog=epilog
    )
    ap.add_argument("--host", default="127.0.0.1")
    ap.add_argument("--port", type=int, default=7497)
    ap.add_argument("--clientId", type=int, default=111)
    ap.add_argument("--symbol", default="ES")
    ap.add_argument("--local-symbol", dest="local_symbol", default="")
    ap.add_argument("--place-orders", action="store_true")
    ap.add_argument("--tif", default="GTC")
    ap.add_argument("--outsideRth", action="store_true")

    # Sizing & Risk
    ap.add_argument("--acct-base", type=float, default=30000.0)
    ap.add_argument("--risk-pct", type=float, default=0.01)
    ap.add_argument("--scale-step", type=float, default=10000.0)
    ap.add_argument("--start-contracts", type=int, default=2)
    ap.add_argument("--max-contracts", type=int, default=6)
    ap.add_argument("--static-size", action="store_true")
    ap.add_argument("--qty", type=float, default=2.0)
    ap.add_argument("--risk-ticks", type=int, default=12)
    ap.add_argument("--tick-size", type=float, default=0.25)
    ap.add_argument("--tp-R", type=float, default=1.0)

    # Margin awareness
    ap.add_argument("--margin-per-contract", type=float, default=13200.0)
    ap.add_argument("--margin-reserve-pct", type=float, default=0.10)

    # Strategy gates
    ap.add_argument("--enable-arms", default="trend,breakout")
    ap.add_argument("--gate-adx", type=float, default=19.0)
    ap.add_argument("--gate-atrp", type=float, default=0.000055)
    ap.add_argument("--gate-bbbw", type=float, default=0.0)  # 0 disables

    # Anti-burst & day/session rails
    ap.add_argument("--min-seconds-between-entries", type=int, default=20)
    ap.add_argument("--max-trades-per-day", type=int, default=12)
    ap.add_argument("--day-loss-cap-R", type=float, default=3.0)
    ap.add_argument("--max-consec-losses", type=int, default=3)
    ap.add_argument("--strategy-cooldown-sec", type=int, default=150)

    # Risk governance extras
    ap.add_argument("--pos-age-cap-sec", type=int, default=1200)
    ap.add_argument("--pos-age-minR", type=float, default=0.5)
    ap.add_argument("--hwm-stepdown", action="store_true")
    ap.add_argument("--hwm-stepdown-dollars", type=float, default=5000.0)

    # Trading window (24/5) + optional TOD blackouts
    ap.add_argument("--trade-start-ct", default="00:00")
    ap.add_argument("--trade-end-ct", default="23:59")
    ap.add_argument("--tod-blackouts", default="")

    # Order behavior
    ap.add_argument("--entry-slippage-ticks", type=int, default=2)
    ap.add_argument("--require-new-bar-after-start", action="store_true")
    ap.add_argument("--startup-delay-sec", type=int, default=0)
    ap.add_argument("--debounce-one-bar", action="store_true")

    # Session resets (AM/PM logging only)
    ap.add_argument("--session-reset-cts", default="08:30,16:00,17:00")
    ap.add_argument("--daily-reset-ct", default="16:10")  # legacy

    # Connectivity & data
    ap.add_argument("--connect-timeout-sec", type=int, default=60)
    ap.add_argument("--timeout-sec", type=int, default=60)
    ap.add_argument("--connect-attempts", type=int, default=10)
    ap.add_argument("--force-delayed", action="store_true")
    ap.add_argument("--poll-hist-when-no-rt", action="store_true")
    ap.add_argument("--poll-interval-sec", type=int, default=10)
    ap.add_argument("--require-rt-before-trading", action="store_true")
    ap.add_argument("--rt-staleness-sec", type=int, default=45)
    ap.add_argument("--rt-starve-sec", type=float, default=3.0,
                    help="Seconds with 0 RT bars before declaring 'starved'")
    ap.add_argument("--force-midpoint-rt", action="store_true",
                    help="Start realtime bars on MIDPOINT instead of TRADES (auto-flip back to TRADES when available)")

    # NEW: strict RT-only
    ap.add_argument("--rt-only", action="store_true",
                    help="No polling; do not trade until RT is FRESH. Overrides --poll-hist-when-no-rt.")

    # Learning
    ap.add_argument("--bandit", choices=["thompson"], default="thompson")
    ap.add_argument("--learn-mode", choices=["shadow","advisory","control"], default="advisory")
    ap.add_argument("--decay-half-life-trades", type=float, default=200.0)
    ap.add_argument("--learn-log", action="store_true")
    ap.add_argument("--learn-log-dir", default=".\\logs\\learn")

    # PnL & equity sync
    ap.add_argument("--use-ib-pnl", action="store_true")
    ap.add_argument("--peak-dd-guard-pct", type=float, default=0.60)
    ap.add_argument("--day-guard-pct", type=float, default=0.025)
    ap.add_argument("--peak-dd-min-profit", type=float, default=1500.0)

    # Short guard rails & VWAP control
    ap.add_argument("--short-guard-vwap-buffer-ticks", type=int, default=4)
    ap.add_argument("--short-guard-min-pullback-ticks", type=int, default=6)
    ap.add_argument("--short-guard-lookback-bars", type=int, default=60)
    ap.add_argument("--short-guard-vwap", action="store_true", default=True)
    ap.add_argument("--no-short-guard-vwap", dest="short_guard_vwap", action="store_false")
    ap.add_argument("--short-guard-lower-high", action="store_true", default=True)
    ap.add_argument("--no-short-guard-lower-high", dest="short_guard_lower_high", action="store_false")
    ap.add_argument("--vwap-reset-on-session", action="store_true", default=True)
    ap.add_argument("--no-vwap-reset-on-session", dest="vwap_reset_on_session", action="store_false")

    # Safety
    ap.add_argument("--allow_live", action="store_true")

    # Risk profile selector
    ap.add_argument("--risk-profile", choices=["balanced","aggressive","conservative"], default="balanced")

    # Optional CSV (placeholder)
    ap.add_argument("--segment-trade-csv", default=r".\logs\trades_segmented.csv")
    return ap

# ---------- Main ----------
def main():
        # ---- block on IB event loop ----
\ \ \ \ try:\n\ \ \ \ \ \ \ \ ib\.run\(\)\ \ \ \#\ blocks\ and\ drives\ timers/callbacks\n\ \ \ \ finally:\n\ \ \ \ \ \ \ \ try:\n\ \ \ \ \ \ \ \ \ \ \ \ ib\.disconnect\(\)\n\ \ \ \ \ \ \ \ except\ Exception:\n\ \ \ \ \ \ \ \ \ \ \ \ pass
    finally:
            ib.disconnect()
        except Exception:
            pass
    finally:
            ib.disconnect()
        except Exception:
            pass
    return 0
    def decay_factor_from_half_life_local(hl_trades: float) -> float:
        hl = max(1.0, float(hl_trades))
        return math.exp(math.log(0.5)/hl)

    class ThompsonGaussian:
        def __init__(self, arms: List[str], decay_gamma: float, prior_mean=0.0, prior_var=0.25):
            self.arms = arms[:]
            self.gamma = decay_gamma
            self.m = {a: prior_mean for a in arms}
            self.s2 = {a: prior_var for a in arms}
            self.w = {a: 1e-6 for a in arms}
            self.last_arm: Optional[str] = None
        def choose(self, cand_arms: List[str], sample: bool):
            scores = {}
            for a in cand_arms:
                std = math.sqrt(max(1e-6, self.s2[a] / (self.w[a] + 1.0)))
                scores[a] = random.gauss(self.m[a], std)
            m = max(scores.values()) if scores else 0.0
            exps = {a: math.exp(scores[a] - m) for a in cand_arms}
            s = sum(exps.values()) or 1.0
            probs = {a: exps[a]/s for a in cand_arms}
            choice = max(probs.items(), key=lambda kv: kv[1])[0]
            if sample:
                r, cum = random.random(), 0.0
                for a in cand_arms:
                    cum += probs[a]
                    if r <= cum:
                        choice = a; break
            return choice, probs
        def update(self, arm: str, reward_R: float):
            g = self.gamma
            w_old = self.w[arm]
            self.w[arm] = g*w_old + 1.0
            m_old = self.m[arm]
            m_new = m_old + (reward_R - m_old) / self.w[arm]
            s2_old = self.s2[arm]
            s2_new = g*s2_old + (reward_R - m_old)*(reward_R - m_new)
            self.m[arm] = m_new
            self.s2[arm] = max(1e-6, s2_new)
            self.last_arm = arm

    arms_enabled = [a.strip() for a in (args.enable_arms or "trend,breakout").split(",") if a.strip()]
    gamma = decay_factor_from_half_life_local(args.decay_half_life_trades)
    learner = ThompsonGaussian(arms_enabled, gamma)

    # Robust commission handler (clarified signature)
    def _on_commission(*args, **kwargs):
        # Accepts (report) or (trade, fill, report)
        trade = fill = report = None
            if len(args) == 3:
                trade, fill, report = args
            elif len(args) == 1:
                report = args[0]
            else:
                report = kwargs.get("report")
                trade  = kwargs.get("trade")
                fill   = kwargs.get("fill")
        except Exception:
            pass
            execId     = getattr(report, "execId", "") if report else ""
            commission = getattr(report, "commission", None) if report else None
            realized   = getattr(report, "realizedPNL", None) if report else None
            side  = getattr(getattr(fill, "execution", None), "side", None) if fill else None
            qty   = getattr(getattr(fill, "execution", None), "shares", None) if fill else None
            price = getattr(getattr(fill, "execution", None), "price", None) if fill else None
        except Exception:
            execId = ""; commission = None; realized = None; side = qty = price = None
        log("commission", execId=execId, commission=commission, realizedPNL=realized, side=side, qty=qty, price=price)

if __name__ == '__main__':
import sys
    sys.exit(main() or 0)







