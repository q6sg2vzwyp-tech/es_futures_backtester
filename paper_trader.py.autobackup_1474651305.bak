#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ES Paper Trader (IBKR + ib_insync) â€” Full Algo Build (2025-11-06)

Key features
- Paper-only safety by default (explicit --place-orders to arm)
- 24/5 trading window (customizable CT windows; daily session cutovers)
- Robust RTâ†’Polling fallback (5s hist bars when RT starved)
- OCO protection (entry + stop + take-profit; orphan sweeps)
- Risk rails: risk_pct per trade, ATR-based stop distance, day-loss cap (R),
  max trades/day, max consecutive losses, HWM stepdown, position age cap
- Short-guards: VWAP buffer and lower-high check (optional)
- News/event kill-switch: file flag + optional blackout clock windows
- Heartbeats (1s) w/ JSON status and CSV trade/perf logs
- Learners: Thompson bandit (strategy/param set selection),
  Discrete Bayesian optimizer over parameter grid (Thompson over per-config
  posteriors), and a simple meta-learner that buckets market regimes and
  transfers priors per regime

Strategy
- SMA(50/200) crossover + RSI filter + ATR-based risk/TP
- Position sizing from risk_pct and stop distance (tick-aware)

Notes
- Designed for ES futures, but contract symbol is CLI arg (--local-symbol).
- Requires: ib_insync. No heavy ML deps required.
- Safe to run without IB connection in "dry" mode for logic tests
  (no orders placed unless --place-orders is passed).
"""

import os, sys, time, json, math, random, argparse, datetime as dt, csv, traceback
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any, Tuple

try:
    from ib_insync import IB, Future, Contract, LimitOrder, StopOrder, MarketOrder, Trade
except Exception as e:
    IB = None  # allow dry run / unit tests without ib_insync

# ========================= Time / TZ =========================
CT = dt.timezone(dt.timedelta(hours=-6))  # User base tz is America/Chicago

def now_ct() -> dt.datetime:
    return dt.datetime.now(CT)

# ========================= Math / TA =========================

def sma(vals: List[float], n: int) -> Optional[float]:
    if len(vals) < n or n <= 0: return None
    return sum(vals[-n:]) / n

def ema(vals: List[float], n: int) -> Optional[float]:
    if len(vals) < n or n <= 0: return None
    k = 2/(n+1)
    e = vals[-n]
    for v in vals[-n+1:]:
        e = v*k + e*(1-k)
    return e

def rsi(vals: List[float], n: int = 14) -> Optional[float]:
    if len(vals) < n+1: return None
    gains = []
    losses = []
    for i in range(-n, 0):
        ch = vals[i] - vals[i-1]
        gains.append(max(0.0, ch))
        losses.append(max(0.0, -ch))
    avg_gain = sum(gains)/n
    avg_loss = sum(losses)/n
    if avg_loss == 0: return 100.0
    rs = avg_gain/avg_loss
    return 100 - (100/(1+rs))

def atr(highs: List[float], lows: List[float], closes: List[float], n: int = 14) -> Optional[float]:
    if len(closes) < n+1 or len(highs) != len(lows) or len(highs) != len(closes):
        return None
    trs = []
    for i in range(1, len(closes)):
        tr = max(highs[i]-lows[i], abs(highs[i]-closes[i-1]), abs(lows[i]-closes[i-1]))
        trs.append(tr)
    if len(trs) < n: return None
    return sum(trs[-n:]) / n

# ========================= Data Classes =========================

@dataclass
class Bar:
    ts: dt.datetime
    o: float
    h: float
    l: float
    c: float
    v: float

@dataclass
class Position:
    direction: int = 0  # -1 short, 0 flat, +1 long
    entry_px: float = 0.0
    size: int = 0
    stop_px: float = 0.0
    tp_px: float = 0.0
    entry_time: Optional[dt.datetime] = None

@dataclass
class Perf:
    day_R: float = 0.0
    trades_today: int = 0
    consec_losses: int = 0
    hwm: float = 0.0

# ========================= Learners =========================

class ThompsonBandit:
    """Simple 2-armed bandit for long/short bias or param-set bucket selection.
    Uses Beta posteriors over win-rate with pseudo counts.
    """
    def __init__(self, arms: List[str]):
        self.arms = arms
        self.win = {a: 1.0 for a in arms}
        self.loss = {a: 1.0 for a in arms}

    def sample(self) -> str:
        draw = {a: random.betavariate(self.win[a], self.loss[a]) for a in self.arms}
        return max(draw.items(), key=lambda kv: kv[1])[0]

    def update(self, arm: str, reward_R: float):
        if reward_R > 0:
            self.win[arm] += 1
        else:
            self.loss[arm] += 1

class DiscreteBayesOpt:
    """Bayesian optimization over a discrete param grid using Thompson sampling.
    We maintain Normal-Gamma posteriors over R for each config and draw samples.
    """
    def __init__(self, configs: List[Dict[str, Any]]):
        self.configs = configs
        self.stats = []  # per-config posterior params
        for _ in configs:
            # Normal-Gamma hyperparams (mu0=0, kappa0=1, alpha0=2, beta0=2)
            self.stats.append({"n":0,"mu":0.0,"m2":0.0,"alpha":2.0,"beta":2.0,"kappa":1.0})

    def sample_config(self) -> Dict[str, Any]:
        draws = []
        for s in self.stats:
            # Student-t like draw via mu + eps*sqrt(beta/(alpha*kappa)) (approx)
            alpha, beta, kappa = s["alpha"], s["beta"], s["kappa"]
            var = (beta/(alpha*kappa)) if alpha*kappa>0 else 1.0
            draw_mu = random.gauss(s["mu"], math.sqrt(max(1e-9, var)))
            draws.append(draw_mu)
        idx = max(range(len(draws)), key=lambda i: draws[i])
        cfg = dict(self.configs[idx])
        cfg["_idx"] = idx
        return cfg

    def update(self, cfg_idx: int, R: float):
        s = self.stats[cfg_idx]
        s["n"] += 1
        # online mean/variance (Welford)
        delta = R - s["mu"]
        s["mu"] += delta / s["n"]
        s["m2"] += delta * (R - s["mu"])
        # update pseudo-obs strength
        s["kappa"] = 1.0 + 0.5*s["n"]
        # update alpha/beta as if Normal-Gamma with unknown variance
        s["alpha"] = 2.0 + 0.5*s["n"]
        s["beta"] = 2.0 + 0.5*max(1e-9, s["m2"])  # scale proxy

class MetaLearner:
    """Very light meta-learning: bucket regimes by (volatility, trend strength)
    and keep a per-bucket DiscreteBayesOpt. On each decision, choose bucket,
    sample best config from that bucket's optimizer, and update post-trade.
    """
    def __init__(self, base_configs: List[Dict[str, Any]]):
        # regime buckets keyed by (vol_bucket, trend_bucket)
        self.base = base_configs
        self.optimizers: Dict[Tuple[int,int], DiscreteBayesOpt] = {}

    def _bucket(self, atr_pct: float, trend: float) -> Tuple[int,int]:
        # atr_pct e.g., ATR/close: 0:(<0.6%), 1:(0.6â€“1.0%), 2:(>1.0%)
        vb = 0
        if atr_pct >= 0.01: vb = 2
        elif atr_pct >= 0.006: vb = 1
        # trend strength from |SMA50 - SMA200|/price
        tb = 0
        if trend >= 0.01: tb = 2
        elif trend >= 0.004: tb = 1
        return (vb, tb)

    def pick(self, atr_pct: float, trend: float) -> Dict[str, Any]:
        key = self._bucket(atr_pct, trend)
        if key not in self.optimizers:
            # init with slightly informative priors based on bucket
            jittered = []
            for cfg in self.base:
                c = dict(cfg)
                # small bias tweaks per bucket
                vb, tb = key
                if vb == 2:  # very volatile: prefer wider ATR mul
                    c["atr_mult"] = min(6.0, c["atr_mult"]*1.3)
                if tb == 2:  # strong trend: smaller RSI gate
                    c["rsi_floor"] = max(30, c["rsi_floor"]-2)
                jittered.append(c)
            self.optimizers[key] = DiscreteBayesOpt(jittered)
        return self.optimizers[key].sample_config()

    def update(self, atr_pct: float, trend: float, cfg_idx: int, R: float):
        key = self._bucket(atr_pct, trend)
        opt = self.optimizers.get(key)
        if opt:
            opt.update(cfg_idx, R)

# ========================= CSV Helpers =========================

class CsvLog:
    def __init__(self, path: str, headers: List[str]):
        self.path = path
        self.headers = headers
        new = not os.path.exists(path)
        self.f = open(path, "a", newline="", encoding="utf-8")
        self.w = csv.DictWriter(self.f, fieldnames=headers)
        if new:
            self.w.writeheader()
            self.f.flush()
    def write(self, row: Dict[str, Any]):
        for k in list(row.keys()):
            if k not in self.headers:
                row.pop(k, None)
        self.w.writerow(row)
        self.f.flush()

# ========================= Trader =========================

class Trader:
    def __init__(self, args):
        self.args = args
        self.ib: Optional[IB] = None
        self.contract: Optional[Contract] = None
        self.rt_enabled = False
        self.last_rt = None
        self.pos = Position()
        self.perf = Perf()
        self.hb_path = os.path.join(args.log_dir, "heartbeats.jsonl")
        self.trd = CsvLog(os.path.join(args.log_dir, "trades.csv"),
                          ["ts","side","qty","entry","exit","R","reason"])
        self.hbl = CsvLog(os.path.join(args.log_dir, "heartbeat.csv"),
                          ["ts","state","net_qty","rt_enabled","rt_age_sec","in_session_window","dayR","trades_today"]) 
        self.rng = random.Random(42)

        # learners
        base_grid = self._build_param_grid()
        self.bandit = ThompsonBandit(["trend", "meanrev"])
        self.meta = MetaLearner(base_grid)
        # news/file kill flag path
        self.kill_flag_path = os.path.join(args.log_dir, "NEWS_KILL.flag")

    # ---------- Setup ----------
    def connect(self):
        if IB is None:
            print("[WARN] ib_insync not available; running in dry mode.")
            return
        self.ib = IB()
        # Try a small range of clientIds to dodge Error 326 automatically
        base = int(self.args.clientId)
        tried: List[int] = []
        for bump in range(0, 6):  # try base..base+5
            cid = base + bump
            try:
                print(f"[IB] Connecting host={self.args.host} port={self.args.port} clientId={cid}...")
                self.ib.connect(self.args.host, self.args.port, clientId=cid)
                self.args.clientId = cid  # lock in the working id
                break
            except Exception as e:
                tried.append(cid)
                msg = str(e)
                if "client id is already in use" in msg.lower() or "already in use" in msg.lower():
                    continue  # try next id
                else:
                    print("[WARN] IB connect attempt failed:", e)
                    self.ib = None
                    return
        if not self.ib.isConnected():
            print(f"[WARN] IB connect failed after trying ids {tried}")
            self.ib = None
            return
        sym = self.args.local_symbol
        self.contract = Future(localSymbol=sym, exchange='CME')
        try:
            self.ib.qualifyContracts(self.contract)
        except Exception as e:
            print("[WARN] Contract qualify failed:", e)
        self.rt_enabled = False
        self.last_rt = None

    # ---------- Param grid ----------
    def _build_param_grid(self) -> List[Dict[str, Any]]:
        grid = []
        for fast in [20, 34, 50]:
            for slow in [100, 150, 200]:
                for rsi_floor in [35, 40, 45]:
                    for atr_mult in [2.0, 2.5, 3.0, 4.0]:
                        grid.append({
                            "fast": fast,
                            "slow": slow,
                            "rsi_floor": rsi_floor,
                            "atr_mult": atr_mult
                        })
        return grid

    # ---------- Session & blackout ----------
    def in_trading_window(self, t: dt.datetime) -> bool:
        # 24/5 default unless user sets narrower windows
        # optional blackout windows (CT) via args.blackout_hrs like "13:00-14:00,08:29-08:31"
        start = self._parse_hhmm(self.args.trade_start_ct)
        end = self._parse_hhmm(self.args.trade_end_ct)
        ok = self._within_window(t.time(), start, end)
        if not ok:
            return False
        if self.args.blackout_hrs:
            for rng in self.args.blackout_hrs.split(','):
                try:
                    a,b = rng.split('-')
                    if self._within_window(t.time(), self._parse_hhmm(a), self._parse_hhmm(b)):
                        return False
                except: pass
        # file/news kill flag
        if os.path.exists(self.kill_flag_path):
            return False
        return True

    def _parse_hhmm(self, s: str) -> dt.time:
        hh, mm = s.split(":")
        return dt.time(int(hh), int(mm))

    def _within_window(self, t: dt.time, a: dt.time, b: dt.time) -> bool:
        if a <= b:
            return a <= t <= b
        # overnight
        return t >= a or t <= b

    # ---------- Data ----------
    def get_bars(self, n: int = 400) -> List[Bar]:
        """Try RT; if not, poll 5s hist bars. Fallback to synthetic if offline."""
        bars: List[Bar] = []
        now = now_ct()
        if self.ib and self.contract:
            try:
                # use historical 5s bars (most robust)
                data = self.ib.reqHistoricalData(
                    self.contract, endDateTime="", durationStr="1200 S",
                    barSizeSetting="5 secs", whatToShow="TRADES", useRTH=False,
                    formatDate=1)
                for b in data[-n:]:
                    ts = dt.datetime.fromtimestamp(b.date.timestamp(), CT)
                    bars.append(Bar(ts, b.open, b.high, b.low, b.close, b.volume))
                self.rt_enabled = True
                self.last_rt = now
            except Exception as e:
                self.rt_enabled = False
        if not bars:
            # offline synthetic walk for testing
            px = getattr(self, "_sim_px", 5000.0)
            for i in range(n):
                px *= (1.0 + (self.rng.random()-0.5)*0.0006)
                bars.append(Bar(now - dt.timedelta(seconds=5*(n-i)), px*0.999, px*1.001, px*0.998, px, 1))
            self._sim_px = px
        return bars[-n:]

    # ---------- Signals ----------
    def signals(self, bars: List[Bar], cfg: Dict[str, Any]) -> Dict[str, Any]:
        closes = [b.c for b in bars]
        highs  = [b.h for b in bars]
        lows   = [b.l for b in bars]
        f = sma(closes, cfg["fast"]) or closes[-1]
        s = sma(closes, cfg["slow"]) or closes[-1]
        r = rsi(closes, 14) or 50.0
        a = atr(highs, lows, closes, 14) or max(1.0, 4.0)
        price = closes[-1]
        trend = abs((f - s)/price)
        atr_pct = a/price
        bias = 1 if f > s else (-1 if f < s else 0)
        # mean reversion flavor when RSI extreme
        mr_long = r < cfg["rsi_floor"]
        mr_short = r > (100 - (cfg["rsi_floor"]))
        return {
            "price": price,
            "f": f, "s": s, "rsi": r, "atr": a,
            "trend": trend, "atr_pct": atr_pct, "bias": bias,
            "mr_long": mr_long, "mr_short": mr_short
        }

    # ---------- Sizing & Orders ----------
    def tick_size(self) -> float:
        return 0.25  # ES

    def dollars_per_tick(self) -> float:
        return 12.5  # ES

    def size_for_risk(self, price: float, stop_dist_points: float) -> int:
        ticks = max(1, int(round(stop_dist_points/self.tick_size())))
        risk_per_ct = ticks * self.dollars_per_tick()
        acct = max(1_000.0, self.args.account_equity)
        risk_dollars = self.args.risk_pct * acct
        qty = int(risk_dollars / max(0.01, risk_per_ct))
        return max(0, min(self.args.max_contracts, qty))

    def place_oco(self, side: str, qty: int, entry: float, stop: float, tp: float) -> None:
    if not self.args.place_orders or not self.ib or not self.contract:
        print(f"[SIM-ORD] {side} qty={qty} entry={entry:.2f} stop={stop:.2f} tp={tp:.2f}")
        return
    try:
        parent_action = 'BUY' if side == 'long' else 'SELL'
        child_action  = 'SELL' if side == 'long' else 'BUY'

        parent = MarketOrder(action=parent_action, totalQuantity=qty, tif='GTC', transmit=False)
        trade: Trade = self.ib.placeOrder(self.contract, parent)
        parent_id = trade.order.orderId

        tp_order = LimitOrder(action=child_action, totalQuantity=qty, lmtPrice=tp, tif='GTC', parentId=parent_id, transmit=False)
        sl_order = StopOrder(action=child_action, totalQuantity=qty, stopPrice=stop, tif='GTC', parentId=parent_id, transmit=True)

        self.ib.placeOrder(self.contract, tp_order)
        self.ib.placeOrder(self.contract, sl_order)
    except Exception as e:
        print("[ORDER-ERR]", e)
# ---------- Risk checks ----------
    def risk_ok(self) -> bool:
        if self.perf.trades_today >= self.args.max_trades_per_day: return False
        if self.perf.consec_losses >= self.args.max_consec_losses: return False
        if self.perf.day_R <= -abs(self.args.day_loss_cap_R): return False
        return True

    # ---------- Main step ----------
    def step(self):
        t = now_ct()
        in_window = self.in_trading_window(t)
        bars = self.get_bars(400)
        closes = [b.c for b in bars]
        highs  = [b.h for b in bars]
        lows   = [b.l for b in bars]

        # Compute regime features for meta-learner
        a = atr(highs, lows, closes, 14) or 4.0
        price = closes[-1]
        f = sma(closes, 50) or price
        s = sma(closes, 200) or price
        trend = abs((f - s)/price)
        atr_pct = a/price

        # pick parameters via meta-learner (Bayesian + Thompson)
        cfg = self.meta.pick(atr_pct, trend)
        sig = self.signals(bars, cfg)

        # Decide side using hybrid: bandit chooses between trend vs meanrev flavor
        flavor = self.bandit.sample()
        side = 0
        if flavor == 'trend':
            side = 1 if sig["bias"] > 0 and sig["rsi"] > cfg["rsi_floor"] else (-1 if sig["bias"] < 0 and sig["rsi"] < 100-cfg["rsi_floor"] else 0)
        else:
            if sig["mr_long"]: side = 1
            elif sig["mr_short"]: side = -1

        # Short guards
        if self.args.short_guard_vwap and side == -1:
            # crude vwap proxy via EMA of typical price
            tp = [(b.h+b.l+b.c)/3 for b in bars]
            vwap_proxy = ema(tp, 60) or price
            if price > vwap_proxy*(1 - self.args.vwap_buffer_pct):
                side = 0
        if self.args.short_guard_lower_high and side == -1:
            # require last high below prior high
            if not (bars[-1].h < bars[-2].h):
                side = 0

        # Position age guard
        if self.pos.direction != 0 and self.pos.entry_time:
            age = (t - self.pos.entry_time).total_seconds()
            if age > self.args.pos_age_cap_sec and sig["price"] != 0:
                # timed exit at market
                R = self._close_position(sig["price"], reason="age_cap")
                self._update_learners(cfg, sig, R)

        # Entry/Exit
        if self.pos.direction == 0 and in_window and self.risk_ok() and side != 0:
            # Determine stop/tp
            stop_dist = sig["atr"] * cfg["atr_mult"]
            qty = self.size_for_risk(sig["price"], stop_dist)
            if qty <= 0:
                self._heartbeat(t, in_window)
                return
            if side == 1:
                entry = sig["price"]
                stop  = entry - stop_dist
                tp    = entry + stop_dist * self.args.tp_R
            else:
                entry = sig["price"]
                stop  = entry + stop_dist
                tp    = entry - stop_dist * self.args.tp_R
            self.place_oco('long' if side==1 else 'short', qty, entry, stop, tp)
            self.pos = Position(direction=side, entry_px=entry, size=qty, stop_px=stop, tp_px=tp, entry_time=t)
        elif self.pos.direction != 0:
            # Check stop/tp
            if self.pos.direction == 1:
                if sig["price"] <= self.pos.stop_px or sig["price"] >= self.pos.tp_px:
                    reason = "stop" if sig["price"] <= self.pos.stop_px else "tp"
                    R = self._close_position(sig["price"], reason=reason)
                    self._update_learners(cfg, sig, R)
            else:
                if sig["price"] >= self.pos.stop_px or sig["price"] <= self.pos.tp_px:
                    reason = "stop" if sig["price"] >= self.pos.stop_px else "tp"
                    R = self._close_position(sig["price"], reason=reason)
                    self._update_learners(cfg, sig, R)

        self._heartbeat(t, in_window)

    def _update_learners(self, cfg: Dict[str,Any], sig: Dict[str,Any], R: float):
        # Update bandit (flavor-level) and meta-optimizer with realized R
        self.bandit.update('trend' if sig['bias']!=0 else 'meanrev', R)
        idx = cfg.get("_idx")
        if idx is not None:
            self.meta.update(sig["atr_pct"], sig["trend"], idx, R)

    def _close_position(self, px: float, reason: str) -> float:
        if self.pos.direction == 0 or self.pos.size <= 0:
            return 0.0
        # realized R in multiples of initial stop distance
        stop_dist = abs(self.pos.entry_px - self.pos.stop_px)
        if stop_dist <= 0: stop_dist = max(self.tick_size(), 1.0)
        pnl = (px - self.pos.entry_px) * (1 if self.pos.direction==1 else -1)
        R = pnl / stop_dist
        self.trd.write({
            "ts": now_ct().strftime("%Y-%m-%d %H:%M:%S"),
            "side": "LONG" if self.pos.direction==1 else "SHORT",
            "qty": self.pos.size,
            "entry": round(self.pos.entry_px,2),
            "exit": round(px,2),
            "R": round(R,3),
            "reason": reason,
        })
        self.perf.trades_today += 1
        self.perf.day_R += R
        if R > 0:
            self.perf.consec_losses = 0
        else:
            self.perf.consec_losses += 1
        self.perf.hwm = max(self.perf.hwm, self.perf.day_R)
        self.pos = Position()  # flat
        return R

    # ---------- HB ----------
    def _heartbeat(self, t: dt.datetime, in_window: bool):
    hb = {
        "ts": t.strftime("%Y-%m-%d %H:%M:%S"),
        "state": "pos" if self.pos.direction!=0 else "-",
        "net_qty": self.pos.size if self.pos.direction!=0 else 0,
        "rt_enabled": self.rt_enabled,
        "rt_age_sec": None if not self.last_rt else max(0.0, (t - self.last_rt).total_seconds()),
        "in_session_window": in_window,
        "dayR": round(self.perf.day_R,3),
        "trades_today": self.perf.trades_today
    }
    os.makedirs(os.path.dirname(self.hb_path), exist_ok=True)
    with open(self.hb_path, "a", encoding="utf-8") as f:
        f.write(json.dumps(hb) + "\n")
    self.hbl.write({k: hb.get(k) for k in self.hbl.headers})
    if self.args.stdout_heartbeat:
        line = (f"HB {hb['ts']} | state={hb['state']} qty={hb['net_qty']} | "
                f"dayR={hb['dayR']:+.3f} trades={hb['trades_today']} | "
                f"rt={'on' if hb['rt_enabled'] else 'off'} age={hb['rt_age_sec'] if hb['rt_age_sec'] is not None else '-'}s | "
                f"session={'ON' if hb['in_session_window'] else 'off'}")
        print(line, flush=True)

# ---------- Daily reset ----------
    def maybe_reset_day(self):
        # Reset counters on session cutovers
        now = now_ct()
        hhmm = now.strftime("%H:%M")
        if hhmm in self.args.session_reset_cts.split(','):
            self.perf = Perf(hwm=self.perf.hwm)  # keep HWM for reference

# ========================= CLI =========================

def build_arg_parser():
    p = argparse.ArgumentParser(description="ES Paper Trader (full algo)")
    p.add_argument('--host', default='127.0.0.1')
    p.add_argument('--port', type=int, default=7497)
    p.add_argument('--clientId', type=int, default=360)
    p.add_argument('--local-symbol', default='ESZ5')
    p.add_argument('--place-orders', action='store_true', help='Arm real order placement')
    p.add_argument('--account-equity', type=float, default=100_000.0)

    # Trading windows & resets
    p.add_argument('--trade-start-ct', default='00:00')
    p.add_argument('--trade-end-ct', default='23:59')
    p.add_argument('--session-reset-cts', default='08:30,16:00,17:00')
    p.add_argument('--blackout-hrs', default='', help='Comma windows HH:MM-HH:MM (CT) to pause trading')

    # Risk rails
    p.add_argument('--risk-pct', type=float, default=0.01)
    p.add_argument('--max-contracts', type=int, default=6)
    p.add_argument('--tp-R', type=float, default=1.0)
    p.add_argument('--day-loss-cap-R', type=float, default=3.0)
    p.add_argument('--max-trades-per-day', type=int, default=12)
    p.add_argument('--max-consec-losses', type=int, default=4)
    p.add_argument('--pos-age-cap-sec', type=int, default=20*60)

    # Short guards
    p.add_argument('--short-guard-vwap', action='store_true')
    p.add_argument('--vwap-buffer-pct', type=float, default=0.0025)
    p.add_argument('--short-guard-lower-high', action='store_true')

    # Logging
    p.add_argument('--log-dir', default=os.path.join(os.getcwd(), 'logs'))
    p.add_argument('--heartbeat-sec', type=int, default=1)
    p.add_argument('--stdout-heartbeat', action='store_true', help='Print a one-line heartbeat every second to stdout')

    return p


def main():
    args = build_arg_parser().parse_args()
    os.makedirs(args.log_dir, exist_ok=True)

    t = Trader(args)
    t.connect()

    last_hb = 0.0
    try:
        while True:
            t.step()
            t.maybe_reset_day()
            # HB pacing
            time.sleep(max(0.05, args.heartbeat_sec))
    except KeyboardInterrupt:
        print("\n[EXIT] Interrupted by user.")
    except Exception as e:
        print("[FATAL]", e)
        traceback.print_exc()

if __name__ == '__main__':
    main()


